<h2>
    C++11
</h2>
<p>
    &nbsp;이 강좌에서는 되도록이면 C++로 소스 코드를 작성하도록 할 것이다. 이 C++이란 물건이
    1983년에 등장한 조상급 언어이다 보니 현대 언어에 비해 유지 보수가 까다롭고
    현재 추세에 맞지 않는 특징들을 갖고 있다. 이를 해결하기 위해 2011년에 제정된 C++11이라는 표준안이
    제정되어 꽤 현대적인 방식으로 C++를 다룰 수 있게 되었고, 그 뒤로도 C++14/17 표준안이 등장하여
    C++은 날로 발전해가는 언어가 되었다. 나는 이 점이 매우 마음에 들기 때문에, 여기서
    C++ 코드를 적을 때 C++11에서 deprecated된 기능들은 가급적 사용하지 않도록 하겠다.
</p>
<p>
    &nbsp;혹시 C++11을 처음 들어보거나 한다면, 적어도 STL Container(std::vector)의 emplace_back
    메서드와 람다 함수, std::shared_ptr, using 지시자의 확장 정도만 알아두어도 절반 이상은 알아볼 수 있다.
</p>
<h2>
    프로그래밍과 행렬
</h2>
<p>
    &nbsp;신경망을 구현할 때는 대량의 수치를 효율적으로 계산하도록 해야 한다. 그 많은 변수들을
    일일이 반복문으로 계산할 수도 있으나, 일련의 변수를 최적화를 통해 한꺼번에 계산할 수 있는
    벡터와 행렬의 연산을 이용하는 것이 가장 좋을 것이다. 따라서 통상적으로 신경망의 최소 단위를
    숫자 하나의 연산이 아닌 행렬의 연산으로 구성하여 프로그래밍한다. 다시 말해 신경망의 구현에는
    벡터와 행렬의 구현이 선행되어야 한다. 그러나 우리가 굳이 행렬까지 직접 구현할 필요는 없다.
    누군가 이미 만들어둔 꽤 효율적인 라이브러리가 C++에서는 수없이 많다. 우리는 그저 감사하는 마음으로
    좋아보이는 행렬 라이브러리를 얻어다 쓰면 된다. 
</p>
<p>
    &nbsp;좋은 C++ 행렬 라이브러리 중에는 아예 GPGPU까지 알아서 해주는 것까지 존재하지만 보통 운영체제 의존적인
    경우가 많다. 그래서 필자는 모든 운영체제, 하드웨어에서 동작하는 순수 라이브러리인
    <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a>을
    주로 사용한다. 물론 다른 것을 써도 좋지만 필자의 입장에서 소스 코드를 작성할 때 그 작동성이 보장되어야
    강좌다운 강좌가 되므로 여기서 등장하는 소스 코드는 Eigen의 사용법을 따른다. 어차피 수식에 맞춰서
    소스 코드를 작성하기에 Eigen을 다뤄본 적이 없더라도 의미하는 바는 쉽게 짐작할 수 있을 것이다.
</p>
<p>
    &nbsp;Eigen에서 행렬을 하나 생성하려면 Eigen::MatrixXd라는 구조체를 이용하면 된다. 코드 작성의 편의를
    위해 이 강좌에서는 다음 코드 한 줄을 이용한다.
</p>
<pre class="brush: cpp">
using matrix = Eigen::MatrixXd;
</pre>
